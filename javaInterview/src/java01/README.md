第一章java特性

包括前四章内容

---

### 第一章  重视基础知识

**1、不可变类**
String 有两种存储方式：   
String str = "Hello";   //存储在常量池中   不可变
String str2 = new String("Hello");   // 存储在内存（堆空间）中

注： 如果一个类成员不是不可变类，要想不受原对象影响，可以调用.clone()方法

**2、不可变类的优劣**
优势：不可变类具有使用简单、线程安全、节省内存等优点
缺点：不可变类的对象因为值的不同而产生新的对象，从而导致无法预料的问题。

引申：对于一些敏感的数据（例如密码），为什么使用字符数组存储比使用String更安全？
答：String字符串是不可变的，存储在常量池中，直到被垃圾回收器回收为止。及时这个字符串不被使用，仍会在内存中存储一段时间（只有GC可以回收，程序员无法直接回收字符串）此时有权访问memory dump（存储器转储）的程序都可能会访问这个字符串，从而把敏感的数据暴露出去。与使用String相比，使用字符串数组，程序员堆数据的生命周期有更好的控制，从而可以增强安全性。

**3、“==”、equals与hashcode**
参考：https://blog.csdn.net/qq_42857603/article/details/81606707
1）如果是基本数据类型那么就用==比较
2）如果是引用类型的话,想按照自己的方式去比较,就要重写这个类中的equals方法,
如果没有重写,那么equals和==比较的效果是一样的,都是比较引用的地址值。
3）如果是比较字符串,那么直接用equals就可以了,因为String类里面已经重写了equals方法,
比较的时候字符串的内容,而不是引用的地址值了。

hashcode方法的返回值与equals方法的关系： 
如果x.equals(y)返回true，即两个对象根据equals方法比较是相等的，那么调用这两个对象中任意一个对象的hashcode必须产生
同样的结果。如果x.equals(y)返回false，那么hashcode有可能相等有可能不等。反过来，hashcode返回值不等，那么equals一定不等，而hashcode相等，equals可能可不等。
也就是equals比hashcode判断相等更为严格。


**4、值传递和引用传递**
值传递，传递的为实参的拷贝；引用传递，传递的为地址
如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

**5、java中的关键字**

- static ：   
    ```$xslt
    可以用来修饰的结构：   属性、方法、代码块、内部类
    静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用
    静态变量的加载要早于对象的创建
    由于类指挥加载一次，则静态变量在内存中也只会存在一份-----存在方法去的静态域中
    注意：在静态的方法内，不能使用this关键字、super关键字
    
    ```


- final：

    ```$xslt
    用来修饰 类、属性、方法，分别表示属性不可变、方法不可覆盖、类不可被继承
    注意：一个类不能即被声明为abstract，又被声明为final
    
    ```

- transient：

    ```$xslt
    用transient关键字标记的成员变量不参与序列化过程。
    ```


- volatile：
    ```$xslt
    
    该字段用于修饰会被多线程访问属性，以保持修改对所有线程可见。
    相比于Synchronized，仅用于修饰字段，且它只会保持线程安全三要素中的可见性和有序性，并不能保证操作的原子性。所以他不严格地保证线程安全。
    
    
    ```

### 第2章 再论面向对象

**6、继承**

继承的主要目的就是为了重组父类的属性或者方法，而不需要重新重复定义。
继承只能是单项的，但是可以通过以下两种方法实现多继承：
```
（1）通过接口实现
（2）通过内部类实现
```

**7、重载和重写的区别？**

> 重写

>> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.

>> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，
实际执行的是子类重写父类的方法。

>> 方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
    						//方法体
     					}
     		约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
     		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
             ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
          	特殊情况：子类不能重写父类中声明为private权限的方法
             ③ 返回值类型：
          	 >父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
          	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
          	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
    		④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 <br>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)

<br>

> 重载

>> 是指同一个类中有多个同名的方法，但这些方法有着不同的参数，因此可以在
编译的时候就可以确定到底调用哪个方法，它是一种编译时多态。重载可以被看作
一个类中的方法多态性

 重载：不表现为多态性。
<br>重写：表现为多态性。
  <br>
  对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
  
  而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”

**8、反射**

反射机制是指对于处在运行状态中的类，都能获取到这个类的所有属性和方法。

对于任意一个对象，都能调用它的任意一个方法以及访问它的属性；这种通过动态获取类或
对象的属性以及方法从而完成调用功能被称为java语言的反射机制。它主要实现了如下功能：
- 获取类的访问能修饰符、方法、属性以及父类信息
- 在运行时根据类的名字创建对象。
- 在运行时判断一个对象属于哪个类
- 生成动态代理

**9、嵌套类**

内部类可以分为很多种，主要有以下四种：

- 静态内部类
- 成员内部类
- 局部内部类
- 匿名内部类

```
class outerClass{
    static class innerClass{}  //  静态内部类
}

class outerClass{
    class innerClass{}   // 成员内部类（普通内部类）
}

class outerClass{
    public void menberFunction(){
        class innerClass{}   // 局部内部类
    }
}

public class MyFrame extends Frame{
    // 外部类
    public MyFrame(){
        addWindowListener(new WindowAdapter()
        {
            // 匿名内部类
            public void windowClosing(WindowEvent e)
            {
                dispose();
                System.exit(0);
            }
        });
    }
}

```

在使用匿名类时，需要牢记以下几个原则：

- 匿名内部类不能有构造函数
- 匿名内部类不能定义静态成员、方法和类
- 匿名内部类不能是public  protected private static
- 只能创建匿名内部类的一个实例
- 一个匿名内部类一定实在new的后面，这个匿名类必须继承一个父类或者实现一个接口
- 因为匿名内部类为局部内部类，所以局部内部类的所有先自都对其生效


### 第3章  泛型

**10、泛型**

引入泛型的两大好处：① 简单安全  ② 性能的提升

泛型提供了以下几个功能：

- 避免代码中的强制类型转换
- 限定类型。在编译时提供一个额外的类型检查，避免错误的值被存入容器
- 实现一些特别的编程技巧。例如： 提供一个方法用于拷贝对象，在不提供额外方法参数的情况下，
使得返回类型和方法参数类型保持一致


疑问：泛型擦除没看懂？？？？ 



