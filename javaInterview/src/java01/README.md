第一章java特性

包括前四章内容

---

### 第一章  重视基础知识

**1、不可变类**
String 有两种存储方式：   
String str = "Hello";   //存储在常量池中   不可变
String str2 = new String("Hello");   // 存储在内存（堆空间）中

注： 如果一个类成员不是不可变类，要想不受原对象影响，可以调用.clone()方法

**2、不可变类的优劣**
优势：不可变类具有使用简单、线程安全、节省内存等优点
缺点：不可变类的对象因为值的不同而产生新的对象，从而导致无法预料的问题。

引申：对于一些敏感的数据（例如密码），为什么使用字符数组存储比使用String更安全？
答：String字符串是不可变的，存储在常量池中，直到被垃圾回收器回收为止。及时这个字符串不被使用，仍会在内存中存储一段时间（只有GC可以回收，程序员无法直接回收字符串）此时有权访问memory dump（存储器转储）的程序都可能会访问这个字符串，从而把敏感的数据暴露出去。与使用String相比，使用字符串数组，程序员堆数据的生命周期有更好的控制，从而可以增强安全性。

**3、“==”、equals与hashcode**
参考：https://blog.csdn.net/qq_42857603/article/details/81606707
1）如果是基本数据类型那么就用==比较
2）如果是引用类型的话,想按照自己的方式去比较,就要重写这个类中的equals方法,
如果没有重写,那么equals和==比较的效果是一样的,都是比较引用的地址值。
3）如果是比较字符串,那么直接用equals就可以了,因为String类里面已经重写了equals方法,
比较的时候字符串的内容,而不是引用的地址值了。

hashcode方法的返回值与equals方法的关系： 
如果x.equals(y)返回true，即两个对象根据equals方法比较是相等的，那么调用这两个对象中任意一个对象的hashcode必须产生
同样的结果。如果x.equals(y)返回false，那么hashcode有可能相等有可能不等。反过来，hashcode返回值不等，那么equals一定不等，而hashcode相等，equals可能可不等。
也就是equals比hashcode判断相等更为严格。


**4、值传递和引用传递**
值传递，传递的为实参的拷贝；引用传递，传递的为地址
如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

**5、java中的关键字**

- static ：   
    ```$xslt
    可以用来修饰的结构：   属性、方法、代码块、内部类
    静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用
    静态变量的加载要早于对象的创建
    由于类指挥加载一次，则静态变量在内存中也只会存在一份-----存在方法去的静态域中
    注意：在静态的方法内，不能使用this关键字、super关键字
    
    ```


- final：

    ```$xslt
    用来修饰 类、属性、方法，分别表示属性不可变、方法不可覆盖、类不可被继承
    注意：一个类不能即被声明为abstract，又被声明为final
    
    ```

- transient：

    ```$xslt
    用transient关键字标记的成员变量不参与序列化过程。
    ```


- volatile：
    ```$xslt
    
    该字段用于修饰会被多线程访问属性，以保持修改对所有线程可见。
    相比于Synchronized，仅用于修饰字段，且它只会保持线程安全三要素中的可见性和有序性，并不能保证操作的原子性。所以他不严格地保证线程安全。
    
    
    ```



