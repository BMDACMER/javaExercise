## 参考资料


---
- 《java高级程序员面试宝典》



### 第一章  重视基础知识

（相关代码在java01文件夹中）

**1、不可变类**
String 有两种存储方式：   
String str = "Hello";   //存储在常量池中   不可变
String str2 = new String("Hello");   // 存储在内存（堆空间）中

注： 如果一个类成员不是不可变类，要想不受原对象影响，可以调用.clone()方法

**2、不可变类的优劣**
优势：不可变类具有使用简单、线程安全、节省内存等优点
缺点：不可变类的对象因为值的不同而产生新的对象，从而导致无法预料的问题。

引申：对于一些敏感的数据（例如密码），为什么使用字符数组存储比使用String更安全？
答：String字符串是不可变的，存储在常量池中，直到被垃圾回收器回收为止。及时这个字符串不被使用，仍会在内存中存储一段时间（只有GC可以回收，程序员无法直接回收字符串）此时有权访问memory dump（存储器转储）的程序都可能会访问这个字符串，从而把敏感的数据暴露出去。与使用String相比，使用字符串数组，程序员堆数据的生命周期有更好的控制，从而可以增强安全性。

**3、“==”、equals与hashcode**
参考：https://blog.csdn.net/qq_42857603/article/details/81606707
1）如果是基本数据类型那么就用==比较
2）如果是引用类型的话,想按照自己的方式去比较,就要重写这个类中的equals方法,
如果没有重写,那么equals和==比较的效果是一样的,都是比较引用的地址值。
3）如果是比较字符串,那么直接用equals就可以了,因为String类里面已经重写了equals方法,
比较的时候字符串的内容,而不是引用的地址值了。

hashcode方法的返回值与equals方法的关系： 
如果x.equals(y)返回true，即两个对象根据equals方法比较是相等的，那么调用这两个对象中任意一个对象的hashcode必须产生
同样的结果。如果x.equals(y)返回false，那么hashcode有可能相等有可能不等。反过来，hashcode返回值不等，那么equals一定不等，而hashcode相等，equals可能可不等。
也就是equals比hashcode判断相等更为严格。


**4、值传递和引用传递**
值传递，传递的为实参的拷贝；引用传递，传递的为地址
如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

**5、java中的关键字**

- static ：   
    ```$xslt
    可以用来修饰的结构：   属性、方法、代码块、内部类
    静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用
    静态变量的加载要早于对象的创建
    由于类指挥加载一次，则静态变量在内存中也只会存在一份-----存在方法去的静态域中
    注意：在静态的方法内，不能使用this关键字、super关键字
    
    ```


- final：

    ```$xslt
    用来修饰 类、属性、方法，分别表示属性不可变、方法不可覆盖、类不可被继承
    注意：一个类不能即被声明为abstract，又被声明为final
    
    ```

- transient：

    ```$xslt
    用transient关键字标记的成员变量不参与序列化过程。
    ```


- volatile：
    ```$xslt
    
    该字段用于修饰会被多线程访问属性，以保持修改对所有线程可见。
    相比于Synchronized，仅用于修饰字段，且它只会保持线程安全三要素中的可见性和有序性，并不能保证操作的原子性。所以他不严格地保证线程安全。
    
    
    ```

### 第2章 再论面向对象

**6、继承**

继承的主要目的就是为了重组父类的属性或者方法，而不需要重新重复定义。
继承只能是单项的，但是可以通过以下两种方法实现多继承：
```
（1）通过接口实现
（2）通过内部类实现
```

**7、重载和重写的区别？**

> 重写

>> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.

>> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，
实际执行的是子类重写父类的方法。

>> 方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
    						//方法体
     					}
     		约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
     		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
             ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
          	特殊情况：子类不能重写父类中声明为private权限的方法
             ③ 返回值类型：
          	 >父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
          	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
          	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
    		④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 <br>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)

<br>

> 重载

>> 是指同一个类中有多个同名的方法，但这些方法有着不同的参数，因此可以在
编译的时候就可以确定到底调用哪个方法，它是一种编译时多态。重载可以被看作
一个类中的方法多态性

 重载：不表现为多态性。
<br>重写：表现为多态性。
  <br>
  对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
  
  而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”

**8、反射**

反射机制是指对于处在运行状态中的类，都能获取到这个类的所有属性和方法。

对于任意一个对象，都能调用它的任意一个方法以及访问它的属性；这种通过动态获取类或
对象的属性以及方法从而完成调用功能被称为java语言的反射机制。它主要实现了如下功能：
- 获取类的访问能修饰符、方法、属性以及父类信息
- 在运行时根据类的名字创建对象。
- 在运行时判断一个对象属于哪个类
- 生成动态代理

**9、嵌套类**

内部类可以分为很多种，主要有以下四种：

- 静态内部类
- 成员内部类
- 局部内部类
- 匿名内部类

```
class outerClass{
    static class innerClass{}  //  静态内部类
}

class outerClass{
    class innerClass{}   // 成员内部类（普通内部类）
}

class outerClass{
    public void menberFunction(){
        class innerClass{}   // 局部内部类
    }
}

public class MyFrame extends Frame{
    // 外部类
    public MyFrame(){
        addWindowListener(new WindowAdapter()
        {
            // 匿名内部类
            public void windowClosing(WindowEvent e)
            {
                dispose();
                System.exit(0);
            }
        });
    }
}

```

在使用匿名类时，需要牢记以下几个原则：

- 匿名内部类不能有构造函数
- 匿名内部类不能定义静态成员、方法和类
- 匿名内部类不能是public  protected private static
- 只能创建匿名内部类的一个实例
- 一个匿名内部类一定实在new的后面，这个匿名类必须继承一个父类或者实现一个接口
- 因为匿名内部类为局部内部类，所以局部内部类的所有先自都对其生效


### 第3章  泛型

**10、泛型**

引入泛型的两大好处：① 简单安全  ② 性能的提升

泛型提供了以下几个功能：

- 避免代码中的强制类型转换
- 限定类型。在编译时提供一个额外的类型检查，避免错误的值被存入容器
- 实现一些特别的编程技巧。例如： 提供一个方法用于拷贝对象，在不提供额外方法参数的情况下，
使得返回类型和方法参数类型保持一致


疑问：泛型擦除没看懂？？？？ 

### 第4章 Java新特性

**11、JDK8**

- Lambda表达式
- 可以在接口总使用关键字default添加默认实现，还可以定义静态方法
- 方法引用 (ClassName::New    ClassName:methodName   instanceName::methodName)
- 注解（@Override   @Deprecated   @SuppressWarnings）
- 类型推测
- 参数名字（在编译的时候增加 -parameters选项，以及增加反射API与Parameter.getName()方法实现获取方法参数名的功能）
- 新增Optional类
- 新增Stream类
- 日期新特性（1.8之前主要三个：Calendar,Date,DateFormat  之后进行了补充）
- 新增调用javaScript
- Base64编码解码
- 并行处理数组（Arrays.paralleXXX()例如：Arrays.paralleSort(arr)）


**12、JDK9**

- JShell（测试的时候比较方便）
- 不可变集合工厂方法
- 私有接口方法
-平台模块系统
- 进程API的改进
- try-catch改进
-Stream API的改进


JDK10，JDK11（LST）改进的都不大，截至到现在最新JDK为13  马上就要迎来JDK14啦

**重点掌握JDK8即可**


### 第5章 Collection框架
 
 （相关代码在java02中）


### 第7章  JavaIO

- 同步和异步关注的是任务是否可以同时被调用，阻塞和非阻塞则关注的是线程的状态
- 同步（synchronized invoke）: 一个执行快同一时间只有一个线程可以访问
- 异步：(asynchronous invoke), 多个执行块可以同时被多个线程访问
- 阻塞： 线程阻塞状态，表示线程挂起
- 非阻塞：线程不处于阻塞状态，表示线程没有挂起

---

BIO(同步阻塞IO模型)

NIO （非阻塞式IO）

AIO（相当于NIO的升级版）

参考：https://www.cnblogs.com/java-chen-hao/p/11083740.html
<br>https://www.cnblogs.com/java-chen-hao/p/11081558.html
<br>https://www.cnblogs.com/java-chen-hao/p/11076176.html

**以下参考尚硅谷2019**

 * 抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）
 * InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))
 * OutputStream    FileInputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()
 * Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())
 * Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()
 
 套路：
 
 1、造文件 File<br>
 2、造流  FileInputStream\FileInputStream   FileReader\ FileWriter <br>
 （如果由buffer的话(缓冲流))，得套一个对应的buffer）<br>
 3、写入、读取操作<br>
 4、关闭
 

### 第8章  JVM

**13、JVM内存划分**

class文件、类装载器子系统、方法去、堆、虚拟机栈、PC寄存器、本地方法栈、执行引擎、垃圾回收器

**14、运行时内存划分**

- 年轻代：（Eden 和两个Survivor（其中一个为空））Eden存储新对象，Survivor负责内存整理，包括复制等操作，作为双缓存
- 老年代：主要存储生命周期较长的对象、超大的对象（无法在年轻代分配的对象）
- 永久代：存放代码、字符串常量池、静态变量等可以持久化的数据。SunJDK将方法去是现在了永久代


**String.intern()**

在使用时，首先在字符串常量池中查找是否存在对应的字符串，若存在，则不执行从堆到字符串常量的复制操作，否则，将堆中的对象复制到字符串常量中。

```
 @Test
    public void test(){
        String s2 = new String("a") + "b";
        s2.intern();
        String s1 = "a" + "b";
        System.out.println(s1 == s2); // true

        String s3 = new String("a") + new String("a");
        String s4 = "aa";
        s3.intern();   //  由于“aa”已经存在  这条代码并不会起作用
        System.out.println(s3 == s4);    // false

    }

```

温馨提示：从JDK1.7开始，HopJVM已经逐步开始把永久代的数据向其它存储空间转移了。如在JDK1.7中把字符串常量池永久代转移到了
JVM的堆空间中，但是永久代并没有完全被移除。

从JDK1.8开始彻底把永久代从JVM中移除了，而把类的元数据梵高本地化的堆内存中（native heap），这一块本地化
的堆内存区域被叫做Metaspace（原空间）

**15、垃圾回收**

- 垃圾回收器<br/>
  第一阶段，串行垃圾回收器<br/>
  第二阶段，并行垃圾回收器<br/>
  第三阶段，并发标记清理回收器（CMS）<br/>
  第四阶段，G1（并发）回收器


    注：G1垃圾回收器的主要设计初衷实在清理非常大的堆空间的时候能够满足特定
    的暂停应用程序的时间。与CMS相比，会有更少的内存碎片。从JDK9开始G1作为了
    默认的垃圾回收器


- 垃圾回收算法 <br/>
  (1) 引用计数算法（简单且低效，JVM不采用）<br/>
  (2) 追踪回收算法 <br/>
  (3) 压缩回收算法 <br/>
  (4) 拷贝回收算法<br/>
  (5) 按代回收算法<br/>
  
  这部分非常重要，是高级java工程师必备技能，采取循序渐进，反复学习的方式，实践为主
  
  
### 第9章 代码的执行

---
这一章相当于讲解java的反射机制（详细可参考尚硅谷笔记）

**16、类加载**

> 类的加载方式分为隐式装载和显式装载。
>> 隐式装载指的是程序在使用new等方式创建对象的时候，会隐式地调用类的加载器
把对应的类加载到JVM中。<br/>
>> 显式装载指的是通过直接调用class.forName()方法来把所需要的类加载到JVM中。


**17、代理模式**